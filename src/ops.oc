#include "edurisc.h"

//uint8_t RISC_RAM[_RISC_RAM_SIZE];
//extern RISC_REG16 A, X, Y, IP; // General purpose (hybrid)

/* NOP */
void RISC_OP_NOP()
{
    return;
}

/* HLT - halts the program, by setting global flag bit 7 to true */
void RISC_OP_HLT()
{
    RISC_GLOBAL_FLAGS |= 0x01;
    return;
}

/* AND - bitwise AND, does not touch unused bits */
void RISC_OP_AND_X8()
{
    uint16_t tX = X | 0xFF00;
    A &= tX;
    return;
}
void RISC_OP_AND_Y8()
{
    uint16_t tY = Y | 0xFF00;
    A &= tY;
    return;
}
void RISC_OP_AND_imm8()
{
    uint16_t ti = RISC_RAM[++IP] | 0xFF00;
    A &= ti;
    return;
}
void RISC_OP_AND_X16()
{
    A &= X;
    return;
}
void RISC_OP_AND_Y16()
{
    A &= Y;
    return;
}
void RISC_OP_AND_imm16()
{
    uint16_t high = RISC_RAM[++IP] << 8;
    uint16_t low = RISC_RAM[++IP];
    A &= (high | low);
    return;
}


/* ADD - arithmetic add operation */
void RISC_OP_ADD_X8()
{
    uint16_t tX = X & 0x00FF; // clear high bits
    uint16_t tA = A + tX; // adds the prepared values
    if( (A & 0xFF00) != (tA & 0xFF00) ) // checks for overflow
        RISC_GLOBAL_FLAGS |= 0x03;
    A = tA;
    return;
}
void RISC_OP_ADD_Y8()
{
    uint16_t tY = Y & 0x00FF; // clear high bits
    uint16_t tA = A + tY; // adds the prepared values
    if( (A & 0xFF00) != (tA & 0xFF00) ) // checks for overflow
        RISC_GLOBAL_FLAGS |= 0x03;
    A = tA;
    return;
}
void RISC_OP_ADD_imm8()
{
    printf("%d\n", IP);
    uint16_t ti = RISC_RAM[++IP] & 0x00FF;
    uint16_t tA = A + ti;
    if( (A & 0xFF00) != (tA & 0xFF00) ) // checks for overflow
        RISC_GLOBAL_FLAGS |= 0x03;
    A = tA;
    printf("%d\n", IP);
    return;
}
void RISC_OP_ADD_X16()
{
    A += X;
    return;
}
void RISC_OP_ADD_Y16()
{
    A += Y;
    return;
}
void RISC_OP_ADD_imm16()
{
    uint16_t high = RISC_RAM[++IP] << 8;
    uint16_t low = RISC_RAM[++IP];
    A += (high | low);
    return;
}
